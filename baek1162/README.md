# 도로포장

https://www.acmicpc.net/problem/1162

문제는 N개의 도시가 주어지고 그 사이 도로와 이 도로를 통과할 때 걸리는 시간이 주어졌을 때 최소 시간이 걸리도록 하는 K개의 이하의 도로를 포장하는 것이다. 도로는 이미 있는 도로만 포장할 수 있고, 포장하게 되면 도로를 지나는데 걸리는 시간이 0이 된다. 또한 편의상 서울은 1번 도시, 포천은 N번 도시라 하고 1번에서 N번까지 항상 갈 수 있는 데이터만 주어진다.

# 내 풀이

# 풀이

## 다익스트라

1. 시작점으로부터의 최단거리를 저장하는 배열을 만든다.
2. 초기값은 아직 시작점으로부터 각 노드들까지의 길을 구하지 못했으므로 $\infty$로, 시작점부터 시작점까지의 거리는 0 으로 초기화한다.
3. 현재 노드는 출발 노드가 된다.
4. 현재 노드의 이웃 노드들에 대해 (배열에 저장된 시작점-현재 노드 최단거리 + 현재 노드에서 이웃 노드까지의 거리) 를 구한다.
5. 위에서 구한 거리가 배열에 저장된 시작점-이웃 노드 최단거리보다 작다면, 값을 갱신한다.
6. 모든 이웃 노드들에 대해 계산을 완료했다면 이 노드는 더이상 방문하지 않는다. 방문할 수 있는 노드 중 가장 가까운 노드를 현재 노드로 하고, 4번으로 돌아가 계산을 수행한다. 이를 선택할 수 없을 때까지 반복한다.
7. 종료 후 각 노드까지의 거리가 최단거리이다.

시작점-모든 노드 최단거리를 구하는 것이 목표이기 때문에 6번에서 방문할 수 있는 노드 중 가장 가까운 노드를 방문하는 것이 최단거리를 찾을 것이라고 기대하기 때문인 것 같다. 이미 정답인 최단거리를 찾았다면 값을 여러 번 갱신할 필요가 없어진다. 즉 연산량이 줄어든다.

## 적용

경로를 탐색할 때, 이 길을 포장 도로로 만들지 아닐지 결정할 수 있다. 무조건 지금 이 도로를 포장한다고 해서 그것이 정답이라는 보장은 없다.

메모이제이션 방식은
- 저장해야 하는 값은 시작점-도시 최단거리이다.
- 사용해야 하는 변수는 어떤 도시, 그리고 오면서 포장한 도로 수이다.

우선순위 큐에서 아이템을 꺼냈을 때 이 도시까지 오면서 도로를 얼마나 포장했는지 알 수 있도록 우선순위 큐 아이템을 {노드, 어떤 경로의 시작점-노드 거리, 포장할 수 있는 도로 수} 로 한다.

0. edge는 도시 간 거리 배열, dist는 포장할 수 있는 도로 수에 따른 시작점-노드 최단거리이다. 우선순위 큐 안의 아이템은 {어떤 루트의 현재 도시, 현재 도시까지의 거리, 포장한 도로 수} 이다.
1. 우선순위 큐에서 d가 가장 작은 아이템 {n,d,k}를 꺼낸다.
2. dist[n][k]가 d보다 작다면 방문할 필요가 없다. 이미 길을 k번 포장하면서 n까지의 더 짧은 루트가 존재하며, 이미 계산이 끝났다.
3. 어떤 이웃 n1 으로 가는 경로를 조사한다.
4. 만약 길을 더 포장할 수 있다면, 길을 포장하고 가는 경우를 조사해야 한다. dist[n][k], dist[n1][k-1] 를 비교해서 값을 갱신한다. 길을 포장했기 때문에 추가 거리는 0이다.
5. 길을 포장하지 않고 가는 경우를 조사한다. dist[n][k]+edge[n,n1], dist[n1][k] 를 비교해서 값을 갱신한다.
6. 모든 이웃에 대한 경로를 조사한다.
7. 큐에서 값을 꺼낼 수 없을 때까지 반복한다. dist[destination] 배열에서 가장 작은 값이 답이다. 길을 다 포장하지 않아도 최단거리일 수 있다.

4,5 에서 거리 계산 시 dist[n][k]를 d로 사용해도 큰 차이는 없는 것 같다. 이미 d를 가진 아이템이 우선순위 큐에 있었다는 것은 dist[n][k] 또한 최단거리로 갱신되었다는 의미를 가진다. 2 에서 dist[n][k] 보다 d가 큰 경우는 우선순위 큐를 통해 계산 순서가 뒤로 밀리고, 결국 무시된다. 

## 구현
```go
func dikjstra(edge map[int][]E) int {
	memo := make([][]int, n+1)
	for i := 0; i <= n; i++ {
		memo[i] = make([]int, k+1)
		for j := 0; j <= k; j++ {
			memo[i][j] = math.MaxInt64
		}
	}
	memo[1][k] = 0

	pq := make(PriorityQueue, 0)
	heap.Init(&pq)
	heap.Push(&pq, &Item{value: 1, priority: 0, skippable: k})

	for len(pq) != 0 {
		t := heap.Pop(&pq)
		i := t.(*Item)

		if i.priority > memo[i.value][i.skippable] {
			continue
		}

		for _, v := range edge[i.value] {
			if i.skippable > 0 {
				if smin := memo[i.value][i.skippable]; smin < memo[v.dest][i.skippable-1] {
					memo[v.dest][i.skippable-1] = smin
					heap.Push(&pq, &Item{v.dest, smin, i.skippable - 1})
				}
			}

			if nmin := memo[i.value][i.skippable] + v.dist; nmin < memo[v.dest][i.skippable] {
				memo[v.dest][i.skippable] = nmin
				heap.Push(&pq, &Item{v.dest, nmin, i.skippable})
			}
		}
	}
	return min(memo[n])
}
```
도시가 최대 5000개가 넘어서 2차원 배열로 그래프의 _양방향_ 엣지들을 저장하려면 메모리가 초과된다. 처음에는 단순하게 [도시1,도시2] 배열을 키로 하는 map을 사용했는데 그러면 이웃한 도시를 찾을 때 edge개수만큼 루프를 돌아야 했다. 그래서 시간초과가 됐었다.

map을 더 효과적으로 쓸 수 있도록 키를 도시1 하나로 두고, 값을 [도시2,거리]로 저장하는 배열 하나와 키를 도시2, 값을 [도시1,거리]로 저장하는 배열을 각각 저장해 메모리 낭비 없이 깔끔하게 이웃을 순회할 수 있었다.
```go
type E struct {
	dest int
	dist int
}
edge := make(map[int][]E)
for i := 0; i < m; i++ {
    var a, b, c int
    fmt.Fscanln(std, &a, &b, &c)
    if edge[a] == nil {
        edge[a] = make([]E, 0)
    }
    edge[a] = append(edge[a], E{b, c})
    if edge[b] == nil {
        edge[b] = make([]E, 0)
    }
    edge[b] = append(edge[b], E{a, c})
}
```

## 에러

없음

# 메모

없음