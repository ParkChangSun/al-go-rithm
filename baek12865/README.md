# 평범한 배낭

https://www.acmicpc.net/problem/12865

0/1 knapsack problem

# 풀이

변수가 두 개이므로 N뿐만 아니라 W까지 고려해서 문제를 나누어야 한다. 

N 개의 아이템을 무게 W 가방에 넣는다.

1. N번째 아이템이 W가방에 들어가지 않는다.

    당연히 N번째 아이템은 제외해야 한다. 따라서 N-1 개의 아이템을 무게 W 가방에 넣는 경우와 같다.

2. N 번째 아이템이 W 가방에 들어간다.

    - N 번째 아이템이 가방에 들어가는 경우는 v(N의 가치) + N-1 개의 아이템을 무게 W-w(N 의 무게) 가방에 넣었을 때 최대 가치이다.

    - N 번째 아이템이 들어가지 않는 경우는 N-1 개의 아이템을 무게 W 가방에 넣는 경우와 같다.

    - 위의 두 경우 중 가치가 큰 것을 선택한다.

    **경우를 나누는 이유는?**
    
    무게가 W인 가방과 N개의 아이템이 있을 때를 생각할 때, N 번째 아이템을 넣는 것이 최대 가치라고 확정할 수 없기 때문이다. LIS때는 들어갈 수 있는 가장 긴 수열에 N을 넣으면 그 자리에서 N이 포함된 가장 긴 수열을 찾을 수 있었지만, knapsack에서는 가장 가치가 높은 경우라고 할지라도 N을 넣는 것이 손해일 수 있다.

이렇게 하면 모든 W 값에 대해 계산할 수 있다. 최대 가치를 얻기 위해, 어떤 아이템을 넣기 위해 다른 아이템을 빼야 하는가? 라는 고민을 할 필요가 없어진다.

## 내 풀이

그동안 DP 문제를 두 문제 정도 풀었는데, 그 문제들은 평범하게 N에 대해서만 메모를 저장하면 풀 수 있었다. 생각해야 하는 변수가 N에만 연관되어 있었다. 그래서 이번에도 N만 생각하면 풀 수 있을 것이라고 생각한 것 같다. 

1. N 아이템을 넣는 최대 밸류는 N 아이템을 넣을 수 있는, 밸류가 최대인 자리에 들어간다.
    
    가장 긴 증가하는 수열과 비슷하게 생각했다. 하지만 단순하게 생각해도 W보다 큰 물건이 존재할 수 있다는 것과, N 아이템이 아주 비효율적인 아이템이라서 들어가지 않는 아이템일 수 있다는 것이다. 하지만 이 방식으로는 비효율적인 아이템이 들어가는 것을 방지할 수 없었다.

2. 정렬해서 밸류가 큰 것부터 차례로 넣는다?

    그리디 방식이다. 만약 밸류가 크지만, 그보다 작은 두 물건의 합이 밸류가 더 크다면 이 방식도 의미가 없다.

그 외의 방법은 생각해 내지 못했다.

## 구현
```go
func pack(n, w int) int {
	if n == 0 {
		return 0
	}
	if memo[n][w] != -1 {
		return memo[n][w]
	}

	if stuff[n][0] > w {
		memo[n][w] = pack(n-1, w)
	} else {
		putn := stuff[n][1] + pack(n-1, w-stuff[n][0])
		notn := pack(n-1, w)
		if putn > notn {
			memo[n][w] = putn
		} else {
			memo[n][w] = notn
		}
	}
	return memo[n][w]
}
```
이 경우도 bottom-up으로 생각하는 것이 오히려 더 쉬웠을 수도 있다. for n for w 순으로 루프를 돌리면 2차원 메모를 깔끔하게 채울 수 있다.

언어 특성상 메모가 0으로 init된다는 것을 다른 메모를 사용해서 해당 자리가 계산된 0인지 계산하지 않은 0인지 확인하는 것이 필요했다. 물론 bottom-up이면 고민 해결이다. geeksforgeeks에서는 메모를 -1로 채우면 따로 체크할 필요가 없이 메모를 채울 수 있는 팁을 알게 됐다. 앞으로는 이렇게 채워야겠다.

## 에러

input 받을 때 i:=1 부터 시작해야 하는데 0부터 하고 있었다. 알고리즘에서는 배열을 N+1 로 선언하고 값을 1부터 채워넣는데, 까먹었는지 0부터였다. 이것 때문에 1시간은 날린 것 같다.