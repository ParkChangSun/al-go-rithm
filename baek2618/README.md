# 경찰차

https://www.acmicpc.net/problem/2618

# 내 풀이 유도 과정

사용 가능한 변수는 사건 번호, 두 차의 현재 위치이며, 저장되는 값은 거리의 최소값이다.
내가 기존에 쓰던 탑다운 방식으로는 풀 수 없다. 애초에 어떤 상황일 때 정답인지 알 수 없기 때문이다.
따라서 함수는 초기 위치를 파라미터로 넣으면서 시작해야 한다.
메모 변수가 사건 번호, 그 사건에 움직인 차 번호인가? 그건 이전의 상황을 다 담을 수가 없다.
두 차는 반드시 초기 위치 또는 사건 위치에 있다.
그렇다고 1000개의 위치의 조합을 다 적을 수도 없다.
계산 중에 두 차의 위치를 변수로 넣어서 기억할 수 있을 것 같다.

# 풀이

어떤 사건을 해결하려면 1번 또는 2번이 그 위치로 이동한다.

사건은 1000개이므로 브루트포스 복잡도는 $2^{1000}$이다.

두 차는 반드시 초기 위치 또는 사건이 발생했던 지점에 위치한다. 따라서 현재 상태는 현재 사건 번호 대신 현재 두 차의 위치를 이용해 나타낼 수 있다.

어떤 상태가 움직인 거리의 최소값을 가지면서 모든 사건이 해결된 상태인지 알 수 없으므로 초기 위치에서 계산을 시작해야 한다. 또는 모든 (a,W), (W,b)를 계산해야 한다.

문제 분할 방식
- 어떤 상태 ```(a,b)``` 는 두 차의 위치를 이용해 나타낼 수 있다.
- 다음 사건 ```C```를 처리했을 때의 상태는 1번 차가 움직였을 때 ```(C,b)``` 또는 2번 차가 움직였을 때 ```(a,C)``` 이다.
- 현재 상태 ```(a,b)``` 에서 마지막 사건까지 처리했을 때(C부터 마지막 사건까지)의 움직인 거리의 최소값은 ```(C,b) + dist(a,C) or (a,C) + dist(b,C)```이다.
- ```(W,b) or (a,W)``` 상태에서는 더 이상 해결할 사건이 없으므로 0이다.
- $\mathit{D}_{ab} = min(\mathit{D}_{aC}+dist(b,C), \mathit{D}_{Cb}+dist(a,C)), \quad C=max(a,b)+1 \leq W$
- 각기 다른 순서로 두 차가 사건을 해결했을 때 상태가 같을 수 있다(aaba, bbba 모두 상태는 (4,3)이다). 따라서 메모 캐싱이 가능하다.

움직인 거리의 최소값을 구했다면 메모를 통해 사건을 해결한 순서를 구할 수 있다.

순서 역추적
- 현재 상태 ```(a,b)```에서 순서를 역추적한다.
- 점화식 $\mathit{D}_{ab} = min(\mathit{D}_{aC}+dist(b,C), \mathit{D}_{Cb}+dist(a,C))$ 에서 두 값을 비교할 수 있다.
    - $\mathit{D}_{ab} = \mathit{D}_{aC}+dist(b,C)$ 라면, 즉 C사건을 2번 차가 해결했다면, $\mathit{D}_{ab} - dist(b,C) = \mathit{D}_{aC}$
    - $\mathit{D}_{ab} = \mathit{D}_{Cb}+dist(a,C)$ 라면, 즉 C사건을 1번 차가 해결했다면, $\mathit{D}_{ab} - dist(a,C) = \mathit{D}_{Cb}$
- 최소값을 택한 것이므로, 위의 두 식 중 하나는 반드시 참이다. 메모 배열에서 $\mathit{D}_{aC},\mathit{D}_{Cb}$ 값을 비교한 후, 현재 상태를 갱신하고 W사건까지 계속 탐색한다.

## 구현
```go
func solve(a, b int) int {
	if max(a, b) == w {
		memo[a][b] = 0
		return 0
	}

	if memo[a][b] != -1 {
		return memo[a][b]
	}

	caseNum := max(a, b) + 1

	aMove := solve(caseNum, b) + dist(a, caseNum)
	bMove := solve(a, caseNum) + dist(caseNum, b)
	memo[a][b] = min(aMove, bMove)
	return memo[a][b]
}

func track(std *bufio.ReadWriter) {
	aPos, bPos := 0, 0

	for i := 1; i <= w; i++ {
		if memo[aPos][bPos]-dist(aPos, i) == memo[i][bPos] {
			aPos = i
			fmt.Fprintln(std, 1)
			continue
		}

		if memo[aPos][bPos]-dist(i, bPos) == memo[aPos][i] {
			bPos = i
			fmt.Fprintln(std, 2)
			continue
		}
	}
}

func dist(n1, n2 int) int {
	p1 := cases[n1]
	p2 := cases[n2]
	if n1 == 0 {
		p1 = []int{1, 1}
	}
	if n2 == 0 {
		p2 = []int{n, n}
	}
	return int(math.Abs(float64(p1[0]-p2[0])) + math.Abs(float64(p1[1]-p2[1])))
}
```

차 위치의 초기값은 (1,1) 또는 (n,n)인데, 이 위치에서 시작하는 경우는 cases 배열에 없다. 그래서 n1인수에 0이 들어오면 1번 차가 초기 위치인 것으로, n2인수에 0이 들어오면 2번 차가 초기 위치인 것으로 판별할 수 있도록 작성하였다.

어떤 사건이 (1,1), (n,n)에서 발생할 수 있기 때문에 메모의 초기값은 -1로 둔다. 역추적에서 마지막 순서에서 움직인 거리 값 0이 필요하므로 0을 세팅한다.

역추적에서 두 값이 동일할 수 있다. 반드시 한 값만 출력된 후 다음 상태로 넘어가야 한다. 처음에 continue처리를 하지 않아서 1,2가 같이 출력되기도 했었다.

# 메모

동적계획법 문제를 풀 때 항상 지금 해결해야 하는 이벤트 번호 (이 문제에서는 사건 번호) 를 반드시 메모 변수로 사용해야 한다는 생각이 계속 박혀 있어서 이번 문제를 접근하기가 너무 어려웠다. 이제는 이벤트 번호를 사용하지 않고도 현재 상태를 나타낼 수 있는지 생각해 볼 수 있을 것이다.

손으로 풀어볼 수 있는 문제는 직접 그려서 풀어봤다면 풀이에 접근했을 수도 있었을 것 같다. 상태를 그려 보고 어떤 것들이 변화하는지 파악해 보는 것이 좋을 것 같다. 