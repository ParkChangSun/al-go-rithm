# 숨바꼭질 3

https://www.acmicpc.net/problem/13549

# 내 풀이 유도 과정

# 풀이

## 0-1 BFS

어떤 정점 N 이 $\mathit{L}_{N}$ 레벨이라는 것은 출발점에서 N 까지 도달하는 동안 가중치가 1인 간선을 $\mathit{L}_{N}$ 번 지났음을 의미한다.

BFS 에서는 탐색 순서를 기억하기 위해 큐를 사용한다. 어떤 노드의 자식 노드는 어떤 노드와 같은 높이의 노드들을 다 탐색한 후 방문할 것이다.

어떤 정점 u에서 간선 $(u,v)$ 를 지나면 다음과 같은 상황이 발생한다.

- $(u,v)$ 의 가중치가 0인 경우, 즉 $\mathit{L}_{v} = \mathit{L}_{u}$ 이다. v 를 큐의 앞에 삽입하면 같은 레벨인 정점들을 전부 탐색할 수 있다.

- $(u,v)$ 의 가중치가 1인 경우, 즉 $\mathit{L}_{v} = \mathit{L}_{u} + 1$ 이다. v 를 큐의 뒤에 삽입하면 u 와 같은 레벨인 정점들을 전부 탐색한 후 u 보다 1레벨 높은 정점들을 탐색할 수 있다.

즉, 어떤 정점에서 비용 없이 갈 수 있는 곳들을 다 탐색한 후 비용이 1인 곳들을 탐색하는 것이다.

### 탐색 프로세스

- 출발점 u 를 방문한다.

    - $\mathit{L}_{u}$ 레벨인 모든 정점, 즉 $(u,v)$ 의 가중치가 0인 노드의 거리를 갱신했다면 큐의 앞에 v 정점을 삽입한다.

    - $\mathit{L}_{u} + 1$ 레벨인 모든 정점, 즉 $(u,v)$ 의 가중치가 1인 노드의 거리를 갱신했다면 큐의 뒤에 v 정점을 삽입한다.
    
    - u의 방문이 종료된 시점에서 큐의 앞에는 $\mathit{L}_{u}$ 뒤에는 $\mathit{L}_{u} + 1$ 레벨인 정점들이 존재하게 된다.

- 큐에서 정점 v 를 하나 꺼낸다.

    - 같은 레벨을 탐색하는 경우 - $\mathit{L}_{v} = \mathit{L}_{u}$ 이라면 v 방문이 종료된 시점에서 큐의 앞에는 $\mathit{L}_{v} = \mathit{L}_{u}$ 뒤에는 $\mathit{L}_{v} + 1$ 레벨인 정점들이 존재하게 된다.

    - 1 높은 레벨을 탐색하는 경우 - $\mathit{L}_{v} = \mathit{L}_{u} + 1$ 이라면 v 방문이 종료된 시점에서 큐의 앞에는 $\mathit{L}_{v} = \mathit{L}_{u} + 1$ 뒤에는 $\mathit{L}_{v} + 1$ 레벨인 정점들이 존재하게 된다.

- 큐가 비어있는 상태($\mathit{L}_{v}$ 값이 최대일 때)가 되거나 목적지에 도달할 때 까지 반복한다.

탐색하는 동안 큐의 앞뒤의 레벨 차는 반드시 1이다. 따라서 이 방식으로 레벨 순으로 모든 레벨의 정점들을 전부 방문할 수 있다.

모든 정점들을 한 번씩만 방문한다. 레벨은 출발점에서의 거리로 사용되므로, 레벨에 따라 순차적으로 모든 정점들을 방문하기 때문에 한 정점을 두 번 이상 방문할 필요가 없다.

이 문제에서는 큐에 아이템을 넣는 순서가 중요했다. 정점 a에서 정점 b로 갈 때 같은 레벨이 아니라면, 가중치가 1인 $a+1$로 계속 가거나, 가중치가 1인 $a-1$로 가다가 가중치가 0인 $(a-n)*2$로 갈 수 있었다. 무조건 후자의 경우를 먼저 큐에 넣는 것이 레벨 순으로 방문할 수 있으므로 방문 순서는 -1이 우선한다.

## 구현
```go
func solve() {
	dist[n] = 0
	deque := []int{}
	deque = append(deque, n)

	for len(deque) > 0 {
		cur := deque[0]
		deque = deque[1:]

		if cur == k {
			return
		}

		if l := cur * 2; l <= 100000 && dist[l] == -1 {
			dist[l] = dist[cur]
			deque = append(deque, 0)
			copy(deque[1:], deque)
			deque[0] = l
		}

		if l := cur - 1; l >= 0 && dist[l] == -1 {
			dist[l] = dist[cur] + 1
			deque = append(deque, l)
		}

		if l := cur + 1; l <= 100000 && dist[l] == -1 {
			dist[l] = dist[cur] + 1
			deque = append(deque, l)
		}
	}
}
```

계산의 우선순위를 주기 위해 cur-1 을 계산하는 코드를 cur+1 을 계산하는 코드 위에 넣었다. 

# 메모

없음