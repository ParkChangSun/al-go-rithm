# 포도주 시식

효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

입력
첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

출력
첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

## 풀이
### 내 풀이

다이나믹 프로그래밍은 큰 문제를 작은 문제로 나누는 것으로 풀 수 있기 때문에 문제를 나누는 것에 집중했다.

만약 N개의 잔을 마신다고 하자. 마실 수 있는 최대값은 N-a 까지의 최대값 + 마지막 a개의 잔에서의 최대값일 것이다.
3개의 잔을 연속으로 마실 수는 없으니 일단 a를 3으로 잡고 문제를 나눠보았다.
가능한 마지막 3잔의 패턴을 생각해 보았다.

```[N-2, N-1, N]``` 으로 각 자리의 잔을 마셨는지를 구분한다.

1. 맨 마지막 잔을 마시지 않는다.

     - 맨 마지막 두 잔을 마신다 ```[011]```

        N, N-1 을 마시고 N-2는 마시지 않아야 한다.
        N-2를 마시지 않기 때문에 그 N-3부터는 가능한 최대값을 사용한다.

    - 마지막 잔을 마시지만 그 전 잔은 마시지 않는다 ```[101, 001]```

        N은 마시고 N-1은 마시지 않아야 한다.
        N-1을 마시지 않기 때문에 N-2부터는 가능한 최대값을 사용한다.

2. 맨 마지막 잔을 안 마시거나 -> ```[110, 010, 100]```

    N을 마시지 않기 때문에 경우를 나눌 필요 없이 N-1부터의 최대값과 동일하다.
    
3. 불가능한 경우 -> ```[111, 000]```
    
    이 경우는 제외한다.

2^3=8 가지 모든 경우를 체크했다. 위의 가능한 경우들 중 가장 높은 값이 N에서의 최대값이 될 것이다.

### 구현
```go
func drink(n int) int {
	if n <= 2 || checked[n] == 1 {
		return store[n]
	}

	notdrinkn := drink(n - 1)
	drinkone := w[n] + drink(n-2)
	drinkboth := w[n] + w[n-1] + drink(n-3)

	l := []int{notdrinkn, drinkone, drinkboth}
	sort.Ints(l)
	store[n] = l[2]
	checked[n] = 1
	return l[2]
}
```
잔의 값이 0인 경우가 존재하여 checked 값을 넣었다. top-down방식으로 구현하여 특정 값을 체크했는지 확인해야 했다. bottom-up으로 구현했다면 필요 없었을 것이다. 

### 에러

메모이제이션 store의 1,2번째 값은 고정된 값이다. 2에서의 최대값은 1,2번째 잔 모두를 마시는 것이기 때문이다. 그러나 N이 1일때 2번째 값을 할당하려 했기 때문에 인덱스 에러가 떴다.

## 생각

이전 풀이를 보고 아주 조금 힌트가 있긴 했지만 그래도 내 힘으로 풀어냈다. 몇 년 만에 다시 잡은 알고리즘인데 바로 풀려버렸다. 문제를 분할하는 것에 집중했고, 운이 좋게 정답인 해법을 찾아냈다.

내 해법은 top-down방식이지만, bottom-up방식의 풀이도 이와 다르지 않을 것이다. 위의 분할한 식을 그냥 루프 안에 넣어서 메모를 채우는 방식으로 고치기만 하면 된다. 여건이 된다면 top-down방식으로 생각하고 bottom-up방식으로 효율성을 높이는 방식이 괜찮은 것 같다.