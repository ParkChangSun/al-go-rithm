# 양팔저울

https://www.acmicpc.net/problem/2629

양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.

무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.

추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.

# 내 풀이

풀이를 생각해내기까지 조금 오래 걸리긴 했지만 내 풀이가 정답이었다. 풀이 섹션에 추론 과정을 적었다.

# 풀이

사용할 수 있는 변수는 양쪽 팔의 무게 또는 그 차이다.

어떤 추가 구슬이 있는 곳에 놓여야 할 수도 있고, 반대편에 놓여야 할 수도 있고, 아예 필요 없을수도 있다. 냅색 문제에서도 어떤 물건을 넣어야 할 수도 있고, 넣지 말아야 할 수도 있다.

문제를 나누어 보면 n번째 추를 놓는 방법은 구슬이 있는 곳에 놓거나, 구슬이 없는 곳에 놓거나, 놓지 않는 것이다. 추를 현재 저울에서 무게가 적은 곳에 놓으면 두 팔 간의 차는 줄어들고, 무게가 많은 곳에 놓으면 차는 늘어난다. 양 팔의 무게의 차를 이용해서 추를 놓는 방식을 전부 서술할 수 있다.

양 팔의 무게의 차이가 K인 저울에 무게 N인 추를 놓는 방법은
1. 구슬이 있는 팔에 놓는다.

    무게차는 K+N 이다. 이 상황은 다시 말하면 무게가 K+N 인 구슬의 무게를 결정하는 문제와 같다.

2. 구슬이 없는 팔에 놓는다.

    무게차는 K-N 이다. 마찬가지로 무게가 K-N 인 구슬의 무게를 결정하는 문제와 같다.

    현재 무게의 차이가 지금 놓으려는 추보다 작아도 결국 이 둘의 차이의 무게를 가지는 구슬의 무게를 결정하는 문제가 된다. 

3. 놓지 않는다.

    이 추를 제외한 추들로 무게가 K 인 구슬의 무게를 결정하는 문제와 같다.

따라서 변수는 추의 번호 1~N, 현재 저울의 무게의 차 1~K 이며 2차원 배열을 사용하여 DP를 구현한다.

N개의 추로 K무게의 구슬을 판별할 수 있다면 N-1개의 추로 K+N or K-N or K 무게의 구슬을 판별할 수 있을 것이다. 세 경우 중 하나라도 판별 가능하다면 이 경우 또한 판별 가능하다.

## 구현
```go
func td(wn, mw int) bool {
	if mw > MAX || wn <= 0 {
		return false
	}
	if weights[wn] == mw {
		return true
	}
	if checked[wn][mw] {
		return memo[wn][mw]
	}

	if td(wn-1, mw+weights[wn]) || td(wn-1, abs(mw-weights[wn])) || td(wn-1, mw) {
		memo[wn][mw] = true
	}
	checked[wn][mw] = true
	return memo[wn][mw]
}

func abs(n int) int {
	if n < 0 {
		n = -n
	}
	return n
}

// main
for i := 1; i <= m; i++ {
    if td(w, marbles[i]) {
        fmt.Fprint(writer, "Y")
    } else {
        fmt.Fprint(writer, "N")
    }
    fmt.Fprint(writer, " ")
}
```
최적의 구현은 아니지만 로직은 다른 사람들과 크게 다르지 않은 것 같다.

무게의 차를 고려하기 위해 절대값을 사용했다.

현재 무게의 차가 지금 놓으려는 추와 같다면 참이라는 조건을 넣어 봤다.

top-down 방식이고 메모의 값이 bool이라 checked배열을 따로 선언했다. 왜 다들 구현을 bottom-up으로 하는지 알겠다.

추의 무게는 다 합해서 최대 15000이지만 구슬의 무게는 최대 40000으로 받을 수 있다. 따라서 배열을 굳이 40000으로 할 필요가 없다. 앞으로 문제를 볼 때는 인풋의 범위를 생각해 볼 수 있겠다.

## 에러

출력은 Y/N 으로 하게 되어 있다. 이걸 안 보고 있어서 조금 헤맸다.

# 메모

없음