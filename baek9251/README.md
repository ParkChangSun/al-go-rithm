# LCS

https://www.acmicpc.net/problem/9251

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

# 풀이

내 풀이가 정답이었다.

## 내 풀이

이번에는 문자열이 두 개가 주어졌기 때문에 두 문자열의 앞에서부터 하나씩 비교하는 것은 불가능했다.
그리고 문자열 두 개가 길이가 다를 수도 있었다.

LIS 같은 문제를 풀 때 N에서 가장 긴 수열을 구하는 방법은 N-1에서의 가장 긴 수열을 이용하는 방식이다.
이 문제는 문자열이 두 개이기 때문에 S1의 N 자리에서, S2의 K 자리에서 가장 긴 수열을 구하는 방식으로 접근했다.

LCS (S1[:N] S2[:K])

1. S1[N] == S2[K]

    LCS (S1[:N-1] S2[:K-1]) + 1

    같은 문자를 찾았다면 양 문자열에서 찾은 문자는 제외한 것에서 다음 문자가 맞는 것까지 찾을 것이기 때문에 N-1 K-1 두 문자열을 탐색한다.

2. S1[N] != S2[K]

    MAX (LCS (S1[:N-1] S2[:K]), LCS (S1[:N] S2[:K-1]))

    N K 를 동시에 -1 하지 않는 이유는 동시에 지워나가면 겹치는 부분까지 같이 날아가기 때문이다.

    한쪽씩 -1 한다면 겹치는 부분을 찾을 수 있다.

    ACAYKP
    CAPCAK

    위 예제에서 LCS(6,5) = 3, LCS(5,6) = 4 이다.

    동시에 -1 한다면 앞의 K는 계산할 수 없게 된다.

    다이나믹 프로그래밍 관점에서는 2차원 배열을 채우기 위해서는 겹치는 문자를 찾은 경우를 제외하면 n,k 에 대해서 1씩 깎으면서 계산을 이어가야 한다.

## 구현
```go
func lcs(n, k int) int {
	if n == 0 || k == 0 {
		return 0
	}
	if memo[n][k] != -1 {
		return memo[n][k]
	}

	if s1[n-1] == s2[k-1] {
		memo[n][k] = lcs(n-1, k-1) + 1
	} else {
		ns1 := lcs(n-1, k)
		ns2 := lcs(n, k-1)
		if ns1 > ns2 {
			memo[n][k] = ns1
		} else {
			memo[n][k] = ns2
		}
	}

	return memo[n][k]
}
```

n,k 0 check (compare with empty string)

memo init with -1

문제를 풀때는 메모 같이 계산에 사용되는 배열을 편의를 위해 N + 1 길이로 설정한다. 따라서 인덱스는 0~N
하지만 문자열은 그런 처리를 따로 하지 않는 이상 0~N-1 이고, 접근할 때도 현재 사용하고 있는 변수를 바로 써서는 안 되는 상황이 있다.
이번 풀이에서는 안 까먹고 처리를 잘 했지만 실수가 날 수 있는 부분이었다.

이번 풀이도 bottom-up 이 오히려 더 쉬운 것 같다. 2중 반복문 돌리면 메모 다 채울 수 있다.

## 에러

없음