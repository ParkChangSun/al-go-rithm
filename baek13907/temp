// package main

// import (
// 	"bufio"
// 	"container/heap"
// 	"fmt"
// 	"math"
// 	"os"
// )

// type PriorityQueue []*Route

// func (pq PriorityQueue) Len() int { return len(pq) }

// func (pq PriorityQueue) Less(i, j int) bool {
// 	return pq[i].dist < pq[j].dist
// }

// func (pq PriorityQueue) Swap(i, j int) {
// 	pq[i], pq[j] = pq[j], pq[i]
// }

// func (pq *PriorityQueue) Push(x any) {
// 	*pq = append(*pq, x.(*Route))
// }

// func (pq *PriorityQueue) Pop() any {
// 	old := *pq
// 	n := len(old)
// 	item := old[n-1]
// 	old[n-1] = nil // avoid memory leak
// 	*pq = old[0 : n-1]
// 	return item
// }

// func addTax() {
// 	type T struct {
// 		toll int
// 		dist int
// 	}
// 	newlist := make([]T, 0)
// 	for t, v := range memo[d] {
// 		if v.dist != math.MaxInt64 {
// 			newlist = append(newlist, T{t, v.dist})
// 		}
// 	}

// 	// 가장 짧은것보다 거리는 길지만 톨은 짧은것만 남겨야 함
// 	// 다른 말로 거리도 길고 톨도 많은것
// 	// 즉 최소값 뒤에 있는 것들은 다 그냥 버리면됨
// 	for _, taxint := range tax {
// 		for i := range newlist {
// 			newlist[i].dist += taxint * newlist[i].toll
// 		}
// 		mindist := math.MaxInt64
// 		cut := 0
// 		for i, v := range newlist {
// 			if v.dist < mindist {
// 				mindist = v.dist
// 				cut = i
// 			}
// 		}
// 		fmt.Println(newlist)
// 		fmt.Println(mindist)

// 		newlist = newlist[:cut+1]
// 	}
// }

// var n, m, k, s, d int
// var edge = make(map[int][]Edge)
// var tax = make([]int, 1)

// func main() {
// std := bufio.NewReadWriter(bufio.NewReader(os.Stdin), bufio.NewWriter(os.Stdout))
// defer std.Flush()

// fmt.Fscanln(std, &n, &m, &k)
// for i := 1; i <= n; i++ {
// 	edge[n] = make([]Edge, 0)
// }
// fmt.Fscanln(std, &s, &d)
// for i := 0; i < m; i++ {
// 	var a, b, c int
// 	fmt.Fscanln(std, &a, &b, &c)
// 	edge[a] = append(edge[a], Edge{b, c})
// 	edge[b] = append(edge[b], Edge{a, c})
// }
// for i := 0; i < k; i++ {
// 	var a int
// 	fmt.Fscanln(std, &a)
// 	tax = append(tax, a)
// }

// memo = make([][]Item, n+1)
// for i := 0; i <= n; i++ {
// 	memo[i] = make([]Item, m+1)
// 	for j := 0; j <= m; j++ {
// 		memo[i][j].dist = math.MaxInt64
// 	}
// }

// 	reached = map[int]map[int]Item{}
// 	for i := 0; i <= n; i++ {
// 		reached[i] = map[int]Item{}
// 	}

// 	dijkstra()

// 	for _, v := range memo {
// 		fmt.Println(v)
// 	}

// 	addTax()
// 	// fmt.Println(memo[d])

// 	// for t := 0; t < k; t++ {
// 	// 	for j := 0; j <= m; j++ {
// 	// 		if memo[d][j].dist != math.MaxInt64 {
// 	// 			memo[d][j].dist += tax[t] * j
// 	// 		}
// 	// 	}
// 	// 	fmt.Println(memo[d])
// 	// }
// }

// type Edge struct {
// 	dest int
// 	dist int
// }

// type Route struct {
// 	node  int
// 	dist  int
// 	tolls int
// }

// type Item struct {
// 	prev int
// 	dist int
// }

// var memo [][]Item

// // 어떤 도시에 어떤 톨로 도달했는지 저장
// // var reached [][]int
// var reached map[int]map[int]Item

// func dijkstra() {
// 	memo[s][0] = Item{s, 0}

// 	pq := &PriorityQueue{}
// 	heap.Init(pq)
// 	heap.Push(pq, &Route{s, 0, 0})

// 	for pq.Len() != 0 {
// 		r := heap.Pop(pq).(*Route)

// 		// 도로수는 같은데 거리가 더 긴것을 거르는것
// 		if r.dist > memo[r.node][r.tolls].dist {
// 			continue
// 		}

// 		// 아래는 도로수가 다른것들 또는 교체될 필요가 있는것들
// 		for _, e := range edge[r.node] {

// 			// 순환 체크
// 			var flag = false
// 			for toll, it := range reached[e.dest] {
// 				// for t, b := range memo[e.dest] {
// 				// 이 루트에서
// 				// 여기에서 저기까지 간 적이 있는 곳에
// 				// 톨이 적고 거리가 긴 경우는 통과해야 함
// 				// 톨이 많고 거리가 긴 경우는 안됨

// 				// 정리하자면, 자신과 이웃인 노드에서 오는것들만 남음
// 				// 근데 그것들 중에는 자신을 거쳐간 경우도 있긴함

// 				// 이미 여기에서 출발해서 저기까지 간적이 있다면
// 				// 그리고 거리가 그게 더 짧다면? 왜감?
// 				if it.prev == r.node && toll <= r.tolls+1 && it.dist < r.dist+e.dist {
// 					flag = true
// 				}
// 				// 여기에서 출발해서 저기까지 처음 가는거라면
// 				// 또는 가봤는데 거리가 더 짧다면?
// 				// 가야지
// 			}
// 			if flag {
// 				continue
// 			}

// 			// 다익스트라 거리 비교
// 			if min := e.dist + memo[r.node][r.tolls].dist; min < memo[e.dest][r.tolls+1].dist {
// 				memo[e.dest][r.tolls+1] = Item{r.node, min}
// 				heap.Push(pq, &Route{e.dest, min, r.tolls + 1})

// 				reached[e.dest][r.tolls+1] = Item{r.node, min}
// 			}
// 		}
// 	}
// }

// // func min(a []int) int {
// // 	b := make([]int, len(a))
// // 	copy(b, a)
// // 	sort.Ints(b)
// // 	return b[0]
// // }

// // 메모 변수는
// // 세금 몇번올렸는지, 도착도시, 지나온 길이 몇개인지
// // 어떤 도시에 도착할 동안 길을 몇개를 지났는가?
// // 길을 몇개 지났는지 알면 얼마나 오르는지도 알수있다

// // func dijkstra() {
// // 	memo[s][0] = 0

// // 	pq := &PriorityQueue{}
// // 	heap.Init(pq)
// // 	heap.Push(pq, &Route{s, 0, 0})

// // 	for pq.Len() != 0 {
// // 		r := heap.Pop(pq).(*Route)

// // 		if r.dist > memo[r.node][r.tolls] {
// // 			continue
// // 		}

// // 		if r.tolls >= m {
// // 			continue
// // 		}

// // 		for _, e := range edge[r.node] {
// // 			min := e.dist + memo[r.node][r.tolls]
// // 			if min < memo[e.dest][r.tolls+1] {
// // 				memo[e.dest][r.tolls+1] = min
// // 				heap.Push(pq, &Route{e.dest, min, r.tolls + 1})
// // 			}
// // 		}
// // 	}
// // }

// // fmt.Fprintln(std, min(memo[d]))
// // for t := 0; t < k; t++ {
// // 	for j := 0; j <= m; j++ {
// // 		if memo[d][j] != math.MaxInt64 {
// // 			memo[d][j] += tax[t] * j
// // 		}
// // 	}
// // 	fmt.Fprintln(std, min(memo[d]))
// // }

// // 6 6 4
// // 1 6
// // 1 2 3
// // 2 3 2
// // 3 4 1
// // 1 4 9
// // 4 5 1
// // 5 6 1
// // 1
// // 1
// // 1
// // 1

// // 8
// // 13
// // 17
// // 20
// // 23