# 세금

https://www.acmicpc.net/problem/13907

주언이는 경제학을 배워 행상인이 되었다. 두 도시를 오가며 장사를 하는데, 통행료의 합이 가장 적은 경로로 이동하려 한다. 도시들은 양방향 도로로 연결되어있으며, 도로마다 통행료가 존재한다.

그런데 정부는 세금 인상안을 발표하였다. 세금을 한 번에 올리면 문제가 발생할 수 있으므로 여러 단계에 걸쳐서 올린다고 한다. 세금이 A만큼 오르면 모든 도로의 통행료가 각각 A만큼 오르게 된다. 세금이 오르게 되면 주언이가 내야 하는 통행료가 변할 수 있다.

주언이를 도와 초기의 최소 통행료와 세금이 오를 때마다의 최소 통행료를 구하시오.

# 내 풀이 유도 과정

세금은 도로 하나하나마다 매겨진다. 거쳐야 하는 도로 수가 많다면 그만큼 세금이 늘어난다.

따라서 기존의 다익스트라에 사용된 도시 번호와 세금 계산에 사용되는 거쳐간 도로 수를 변수로 한다.

저장해야 하는 값은 최단거리이다.

메모 선언을 (도시 개수)*(도로 개수) 로 선언했다. 여기까지는 쉽다.

타임아웃이 발생한다. 이유는 다익스트라로 채워야 하는 메모가 너무 많다.

어떤 도시로 가는 데 같은 도로를 몇 번이고 이용해서 도착하는 경우를 전부 기록한다. 즉 순환하는 경우가 너무 많다.

순환을 탐지하기 위해 여러 방식을 생각해 보았다.

- 우선순위 큐에서 거쳐간 도로 수가 작은 것부터 뽑는다? 거쳐간 도로 수가 적다고 금액이 작은 것은 아니다.
- 도착 도시에 도착하면 큐에 저장하지 않는다? 그러면 몇 개 정도는 줄일 수 있다. 그러나 큰 의미는 없다.
- 어떤 루트의 이전 도시를 기억해서 또 이전 도시에서 오는 경우는 계산하지 않는다? 만약 (복잡한 그래프)-a-b-c-d 이렇게 이어진 상태라면 구해야 하는 경우까지 무시된다.
- 또한 모든 루트들에 대해 이전 도시에서 출발했는지 아닌지 반복문을 돌려야 하므로 (memo[t]) 시간 복잡도는 줄어들지 않았다.
- 모든 중간 도시들은 무조건 최단거리만을 저장해야 한다? 즉, 어떤 루트가 이미 계산한 기존의 루트보다 거쳐간 도로 수가 많고 금액도 크다면 이 루트는 불필요하게 긴 도로를 이용했을 것이다.

결과적으로, 모든 도시들은 불필요한 루트, 즉 기존의 루트보다 금액도 큰데 거쳐간 도로도 많다면 이 루트는 계산해서는 안 된다.

세금은 거쳐간 도로에 따라 증가하는데, 이미 금액도 크기 때문에 절대 최소 금액이 될 수 없다.

금액은 크지만 거쳐간 도로가 작다면 세금이 오름에 따라 충분히 최소 금액이 될 수 있다.

해결책을 찾았으나 이 이후에는 코드가 이미 괴물이 되어 있어서 제대로 구현하지 못하고 완전히 새로 짜야 했으며, 이 방식을 적용하지 못해 인터넷을 찾아봤다.

이후 추가적인 최적화는 풀이에 기술한다.

# 풀이

문제 분할 방식은

- 어떤 도시로 가는 최적의 루트와 거쳐간 도로 수이다.
- 메모 변수는 도시 번호, 거쳐간 도로 수이다.
- 저장해야 하는 값은 최소 금액이다.

최적의 루트란 도시 a까지 가는 데 b만 거쳐서 가는 최적의 루트가 있다면 굳이 c,d,e를 거쳐서 가는 루트를 저장하지 않는 것이다. 최적의 루트를 두고 굳이 금액도 많고 세금도 많이 낼 루트를 갈 이유가 없다.

메모 배열은 (도시 번호) X (도시 번호)로 한다. 최적의 루트는 같은 도시를 다시 방문하지 않는다. 따라서 도시가 1000개일 때 거쳐간 도로 수는 최대 999개이다. 따라서 (도시 번호) X (도로 수) 로 할 필요가 없다.

우선순위 큐 아이템을 {현재 도시, 금액, 거쳐간 도로 수}로 한다.

다익스트라 알고리즘의 진행 방식은 다음과 같다.

0. 시작 도시의 초기값을 설정한다.
1. 우선순위 큐에서 금액이 가장 작은 아이템을 꺼낸다.
2. 이 루트의 현재 도시로 가는 금액이 메모 배열의 이 도시로 이 루트의 같은 수만큼의 도로를 거쳐간 금액보다 크다면 더이상 계산할 필요 없이 (1)로 돌아간다.
3. 또는 거쳐간 도로 수가 n보다 크다면 잘못된 루트이므로 (1)로 돌아간다.
4. 이 루트의 현재 도시의 이웃 도시에 대해 금액을 계산한다.
5. 만약 이웃 도시에 이 루트보다 금액과 거쳐간 도로 수 모두 작은 루트가 이미 계산되었다면 이 루트는 최적의 루트가 아니다. 따라서 (4)로 돌아간다.
6. 이웃 도시로 이 루트만큼 도로를 거쳐간 최소 금액을 갱신했다면, 우선순위 큐에 새로운 아이템을 푸쉬한다. (1)로 돌아간다.

또한 최대 30000번의 세금 인상별 최소 금액을 계산해야 한다. 사실 이 최적화는 굳이 필요는 없다.

- 다익스트라로 계산한 (도착지의 거쳐간 도로 수에 따른 금액 리스트) 를 가져온다.
- 세금을 인상하지 않은 최소 금액을 계산한다. 이 뒤의 리스트는 모두 최소 금액보다 거쳐간 도로 수도 많고, 금액도 많다. 따라서 세금을 인상한다고 해도 절대 최소 금액을 가지는 루트가 될 수 없다. 따라서 이 뒤의 리스트는 버린다.
- 이런 방식으로 세금을 올리고 필요 없는 부분은 버리며 모든 세금 인상을 계산한다.

## 구현
```go
func dijkstra() {
	memo[s][0] = 0
	pq := &PriorityQueue{}
	heap.Init(pq)
	heap.Push(pq, &Route{s, 0, 0})

	for pq.Len() != 0 {
		r := heap.Pop(pq).(*Route)

		if r.toll > n || r.dist > memo[r.current][r.toll] {
			continue
		}

	OPTIMALFOUND:
		for _, e := range edge[r.current] {
			min := e.value + memo[r.current][r.toll]

			for i := 1; i < r.toll; i++ {
				if memo[e.dest][i] <= min {
					continue OPTIMALFOUND
				}
			}

			if min < memo[e.dest][r.toll+1] {
				memo[e.dest][r.toll+1] = min
				heap.Push(pq, &Route{e.dest, min, r.toll + 1})
			}
		}
	}
}

// main
arr := memo[d]
for _, tax := range taxes {
    min := math.MaxInt32
    cut := 0
    for i := range arr {
        arr[i] += tax * i
        if arr[i] < min {
            min = arr[i]
            cut = i
        }
    }
    fmt.Fprintln(std, min)
    arr = arr[:cut+1]
}
```

# 메모

처음 메모를 선언할 때 (도시 수) X (도로 수) 로 했었는데 그래서 메모리를 비정상적으로 많이 사용했었다. 내가 간과했던 것은 "내가 구해야 하는 것은 최적의 루트들이고, 최적의 루트는 같은 도시를 두 번 방문하지 않는다" 였다. 이 사실을 뒤늦게 풀이를 보고 힌트를 얻었다. 물론 처음 선언할 때 이상함을 느끼지 않은 것은 아니었다.

하지만 다음 풀이에서는 이런 인사이트를 얻었으니 메모의 범위를 잘 고려해야겠다.