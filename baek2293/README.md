# 동전1

https://www.acmicpc.net/problem/2293

n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

# 내 풀이

동전을 이용해서 특정 가격을 만든다는 것을 보고 10원을 만들기 위해서는 9원을 만드는 방법에 동전 1을 더하고, 8원을 만드는 방법에 2를 더하고... 이런 방식으로 문제를 나눌 수 있었다.

그래서 각 가격 당 만들 수 있는 경우의 수를 메모하기 위해 1차원 배열을 만들어 계산을 하려 했다.

하지만 탑다운 방식으로 메모를 작성하는 것은 중복을 처리할 수 없었다. 3을 만드려면 1에 2를 더할 수 있고, 2에 1을 더할 수도 있었다. 1차원 배열을 사용하는 탑다운 방식은 각 자리에 메모를 적을 때 모든 계산을 끝낸 최종 답을 적으려 하기 때문에 1(1) 에서의 메모와 2(2) 에서의 중복을 모두 더할 수 밖에 없었고, 중복을 처리할 다른 방법을 떠올리지 못했다.

# 풀이

메모리 제한 때문에 top-down으로 풀 수는 없다. 하지만 식을 세우는 접근법은 동일하다.

배열을 2차원으로 할 수 없을 것이라 생각했는데 변수를 가치 그리고 사용한 동전의 가지수로 사용할 수 있다. 

가치 v 를 k1 동전으로만 만드는 경우는 1가지 밖에 없다.

가치 v 를 k1, k2 동전으로만 만드는 경우는 기존 값에 [v - k2][1] 의 값을 그대로 더해주기만 하면 된다. 동전의 가짓수가 하나 늘은 것이고 v-k2 의 경우들만 더해주면 되기 때문에 중복이 발생하지 않는다.

동전의 가짓수라 함은 k1, k2, k3 ... 일 때 1가지는 k1, 2가지는 k1, k2, 3가지는 k1, k2, k3 이다.

이 계산을 반복한다.

내 풀이에서 중복이 발생한 이유는 어떤 가치에서 나올 수 있는 모든 경우의 수, 즉 모든 동전을 다 사용하는 방법들을 계산한 것이고, v-k1, v-k2 도 모두 동일하게 모든 경우의 수를 다 계산했기 때문에 위와 같은 중복이 발생했다.

중복이라는 것은 몇 가지의 동전을 사용했지만 배열 순서만 다른 경우라고 할 수 있다. 이 문제에서 계산하는 것은 v-k1 이라는 값을 만드는 경우들의 뒤에 k1 을 덧붙이는 형태라고 할 수 있는데, 메모를 가치와 동전의 가짓수로 정하면 몇 가지의 동전을 사용하는 경우들만 깔끔하게 쌓아나갈 수 있다.

## 구현
```go
func coin(v int) int {
	for _, v := range coins {
		for i := 0; i <= k; i++ {
			if d := i - v; d >= 0 {
				memo[i] += memo[d]
			}
		}
	}
	return memo[k]
}
```
메모리 제한이 4MB 였다. 문제를 풀 때 메모리 제한을 보고 풀 수 있는 방법을 결정해야 한다.

## 에러

없음

# 메모

경우의 수 문제이고, 관련된 문제를 풀어본 적이 없어서 그런지 접근하기가 까다로웠던 것 같다. 어찌저찌 변수 설정을 잘 했더라면 풀었을 수도 있겠지만, 조합과 관련된 공부를 할 수 밖에 없다.