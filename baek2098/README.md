# 외판원 순회

https://www.acmicpc.net/problem/2098

1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.

N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

# 내 풀이

문제를 나눠보려고 했는데 나눌 수가 없었다.

- 0부터 모든 도시를 차례대로 계산하기에는 무조건 첫 번째에서 두 번째 도시로 간다는 보장이 없기 때문에 불가능했다.
- 0부터 i개의 도시까지 가는 최단거리를 계산하기에는 0부터 i+1번째 도시까지의 거리를 계산하는 것과 전혀 관계가 없었기에 불가능했다.
- 그렇다면 방문한 도시들을 제외하고, 다음 최단거리에 속하는 도시로 가야 하는데 이것을 어떻게 저장해야 할까?

일단 0번째 도시에서 출발하는 최단 순회 거리를 찾으면 그것이 곧 정답이다 - 1번째에서 출발하든 N번째에서 출발하든 결국 사이클을 이루기 때문에 모두 동일하다 - 는 사실은 알고 있었다. 하지만 문제를 어떻게 나누고, 메모에 사용하는 변수가 무엇이고, 메모해야 하는 값이 무엇인지 알 수가 없었다.

풀이를 참고하여 알게 되었지만 변수는 현재 도착한 도시, 그리고 방문한 도시 목록(비트마스크)였다.

# 풀이

주어진 그래프는 반드시 순환한다는 조건이 있었다.

어떤 순환하는 그래프의 비용은 출발지에서부터 모든 도시들을 방문한 후, 마지막 도시에서 출발지로 가는 비용을 더한 것이다.

따라서 다이나믹 프로그래밍으로 구해야 하는 값은 사이클의 마지막 방문지에서 출발지로 도착하는 비용 하나만 제외한 값, 다시 말해 출발지에서 N개의 도시들을 최소로 돌되 사이클에 포함되어야 한다.

이 문제를 분해하는 방법은 다음과 같다.

- 어떤 도시에서는 방문하지 않은, 방문 가능한 모든 도시들을 방문할 수 있다. 출발지에서 N 도시로 방문한다면, 사이클에 포함되는, N 도시에서 출발하는 마지막 방문지까지의 거리의 최소값을 구하는 것으로 생각할 수 있다.
- 1,2,3,...,N 순으로 순회하는 방식이 아니기 때문에 어떤 도시를 방문했는지 기록할 필요가 있는데, 이 기록을 비트마스크를 사용한다. N개의 도시를 방문한 기록은 $2^N$가지가 있다.

따라서 사용하는 변수는 현재 도시 번호, 그리고 방문 기록 비트마스크이다.

1. 어떤 N도시에서 방문하지 않은 도시들 중 하나인 M 도시를 방문했을 때의 최종 비용, M+1 도시를 방문했을 때의 최종 비용... 들 중 최소값이 이 알고리즘에서 찾고자 하는 값이다.

2. 모든 도시를 방문한 경우, 방문할 수 있는 곳은 출발지 하나뿐이다. 이 경우에는 현재 도시에서 출발지로 가는 비용만 리턴한다.

## 구현
```go
func route(current int, visited int) int {
	if memo[current][visited] != 0 {
		return memo[current][visited]
	}
	if visited == finish {
		if W[current][0] == 0 {
			return math.MaxInt32 / 2
		}
		return W[current][0]
	}

	ans := math.MaxInt32 / 2
	for i, bit := 0, 1; i < N; i, bit = i+1, bit<<1 {
		if visited&bit == bit || W[current][i] == 0 {
			continue
		}
		ans = min(ans, route(i, visited|bit)+W[current][i])
	}

	memo[current][visited] = ans
	return memo[current][visited]
}

// main
fmt.Fprintln(writer, route(0, 1))
```

`<<`연산자를 사용해서 몇 번째 도시를 방문했는지를 체크한다.

최소값을 구하는 과정에서 `route(i, visited|bit)+W[current][i]`가 오버플로우가 날 수 있다. 예를 들어 마지막 방문지에서 출발지로 가는 길이 없는 경우 무한값을 더해줘야 하는데, 보통 코드에서는 정수 최대값을 주기 때문에 오버플로우가 될 수 있다. 따라서 최대값에 나누기 2를 한 값을 사용한다.

0번 도시에서 시작하고, 방문지는 출발지인 0번을 체크하는 1 (000...1) 로 준다.

## 에러

마지막 도착지에서 출발지로 가는 길이 없을 수 있다는 것을 생각하지 못했다.

이런 것들이 문제를 풀면서 가장 어려운 부분인 것 같다. 그러니 알고리즘을 다 구현한 후에는 항상 예외 사항에는 어떤 것이 있는지 체크해야 한다.

# 메모

없음