# 팰린드롬 분할

https://www.acmicpc.net/problem/1509

# 풀이




문자열의 a~b 부분이 팰린드롬이라면 값을 비교할 수 있다. 1~a-1까지 팰린드롬 분할의 최솟값+1, 기존의 1~b까지의 팰린드롬 분할의 최솟값 중 작은 값을 선택한다.

따라서 어떤 n까지의 부분 문자열의 팰린드롬 분할의 최솟값은 1~n의 수들을 반복문으로 k값에서 k~n까지의 문자열이 팰린드롬인지 확인 후 최솟값을 선택해야 한다.


$m$ : 팰린드롬 분할의 최솟값 저장 배열 inf로 init되어 있음

$P$ : 팰린드롬 확인 함수

$m[n]=\begin{cases}Min(m[k-1]+1, m[n]) & P(k,n)=true \\ 
m[n] & P(k,n)=false\end{cases} k=1 \dots n$

모든 부분문자열에 대해 팰린드롬을 체크하므로 바텀업으로 채우는 것이 효율적이다.

두 수의 차가 0,1... 인 경우를 차례로 계산한다.

$memo$ : 팰린드롬인지 기록하는 메모

$memo[a][b]=\begin{cases}true & a=b \lor a+1=b \\ 
true & s[a]=s[b] \land memo[a+1][b-1] \\
false & else
\end{cases}$

memo[a+1][b-1] 값이 undefined인 경우는 없다. 두 수의 차가 작은 경우를 이미 계산해 놨기 때문이다.

# 내가 틀린 부분

팰리드롬을 재귀로 생각하지 못하고 일일이 반복문으로 확인했다. 다시 풀었을 때 탑다운으로 하는 방식이 너무 비효율적이었다. 원래 풀이도 팰린드롬이 없는 예외에서 거의 시간초과였는데 재귀까지 하느라 시간이 더 걸렸을 것이다.

앞에 빈문자열을 만들면 최대 인덱스에 +1하는 트릭을 쓸 수 있다.

# 메모

실제 풀이는 바텀업이 아니다.