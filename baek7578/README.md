# 공장

https://www.acmicpc.net/problem/7578

어떤 공장에는 2N개의 기계가 2열에 걸쳐 N개씩 배치되어 있다. 이 2개의 열을 각각 A열과 B 열이라고 부른다. A열에 있는 N개의 기계는 각각이 B열에 있는 N개의 기계와 하나씩 짝을 이루어 케이블로 연결되어 있다. 즉, A열의 임의의 기계는 B열의 유일한 기계와 케이블로 연결되어 있고, B열의 임의의 기계는 A열의 유일한 기계와 케이블로 연결되어 있다

또한, 각 기계에는 식별번호가 붙어있으며, 짝이 맺어진 기계끼리는 같은 식별번호가 붙어있다. 즉, 각 열에 있는 N개의 기계끼리는 서로 다른 식별번호를 가지고 있으며, 반대쪽 열에 있는 같은 식별번호를 가진 기계와 케이블로 이어져 있다.

공장 작업의 효율성을 위해 기계들은 짝을 맺은 순서대로 배치되지 않으며, 필요에 따라 각 열의 기계들의 순서를 바꾼 바람에 케이블은 마구 엉켜있는 상태이다. 이렇게 엉켜버린 케이블은 잦은 고장의 원인이 되기 때문에, 기계의 위치를 바꾸지 않은 상태에서 케이블을 두 기계를 잇는 직선의 형태로 만들기로 했다.

예를 들어, 위의 그림과 같이 N = 5이고, A열에 위치한 기계의 식별번호가 순서대로 132, 392, 311, 351, 231이고 B열에 위치한 기계의 식별번호가 순서대로 392, 351, 132, 311, 231이라면 케이블들의 교차 횟수 혹은 서로 교차하는 케이블 쌍의 개수는 3이 된다.

정수 N과 A열에 위치한 기계, B열에 위치한 기계의 식별번호가 각각 순서대로 주어질 때에 서로 교차하는 케이블 쌍의 개수를 정확하게 세어 출력하는 프로그램을 작성하시오.

# 내 풀이

내 힘으로 풀지는 못했다.

단순히 루프를 도는 것은 당연히 시간초과가 날 것인데, 누적해서 계산할 방법을 찾지 못한 것이다.

자신과 같은 식별번호를 가진 기계보다 더 뒤에 있는 것들을 누적적으로 세면 정답이라는 것은 알고 있었다.

132 392 311 351 231
392 351 132 311 231

이 예제를 계산할 수 있도록 단순화하면 3 1 4 2 5 이런 배열을 얻을 수 있다. 3은 맨 앞이니까 아무것도 안 하고, 1은 앞에 3이 있으니 누적합에 1을 더하고, 4는 없고, 2는 2개 있고... 하지만 여기서 트리를 어떻게 사용해야 하는지는 감을 못 잡았다.

# 풀이

inverse counting이라는 문제 유형이다. 루프를 통해 현재 수보다 더 큰 수들을 세는 데 세그먼트 트리를 사용할 수 있다.

계산 프로세스로 돌아가보자.
- 첫번째 원소 3에서는 체크할 필요가 없다.
- 두번째 원소 1에서는 3을 체크했다. 따라서 두번째 원소에서 체크한 값은 1개다.
- 세번째 원소 4에서는 체크할 것이 없다.
- 네번째 원소 2에서는 2보다 큰 것이 2개 있다. 3과 4가 있다. 따라서 결과값에 더해야 하는 값은 2다.
- 5번째 원소에서는 체크할 것이 없다.

자신보다 큰 원소들을 체크해야 한다. 만약 두 번째 원소 1을 체크할 때 3의 값이 1이라면, 즉 1보다 큰 값들이 체크되어 있다면 그냥 체크된 값들을 세기만 하면 된다. 네 번째 원소 2에서도 마찬가지로 자신보다 큰 체크되어 있는 값들만 세면 된다.

따라서 어떤 원소 n보다 큰, 체크된 값들을 세는 것은 n+1부터 끝까지, 1로 되어있는 값들의 합을 구하는 것이다. 이는 세그먼트 트리의 query(n,max) 로 생각할 수 있다. 이 문제는 모든 교차를 구하는 것이므로 이 값을 결과값에 더한다.

이후 update(n,1)로 체크해주면 다음 계산에 사용된다.

## 구현
```go
// input
a := make([]int, n)
for i := 0; i < n; i++ {
    fmt.Fscan(std, &a[i])
}
index := make([]int, 1000001)
for i := 1; i <= n; i++ {
    var b int
    fmt.Fscan(std, &b)
    index[b] = i
}

treeSize := 1 << int(math.Ceil(math.Log2(float64(n)))+1)
tree = make([]int, treeSize+1)
ans := 0
for _, v := range a {
    ans += query(1, 1, n, index[v], treeSize)
    update(1, 1, n, 1, index[v])
}
fmt.Fprintln(std, ans)
```
기계들의 윗줄과 아랫줄이 입력으로 들어온다. 이 코드에서는 두 줄의 기계의 순서를 저장한 후 계산을 실행한다. 식별 번호의 최대값이 100000이라는 점을 이용해서 식별 번호를 루프를 통해 1부터 차례대로 저장하는 생각을 할 수 있었다. 하지만 더 좋은 점은 애초에 a배열을 저장할 필요 없이 첫번째 줄을 두번째 줄인 것처럼 계산할 수 있었다. 두 줄을 바꿔도 결과에는 아무런 영향이 없다는 것을 이용한 것이다.

트리 배열의 크기를 구할 때, 정석대로 로그를 통해 계산했다. 완전 이진 트리에서는 리프노드 n이 주어지면, 2의 거듭제곱을 n보다 클때까지 한 후, 한 번 더 2를 곱하면 로그를 사용한 것과 똑같은 값을 얻을 수 있다. 원리는 동일하다.
```
for treeSize<N
    treeSize*=2
treeSize*=2

index[1000001]
for i := 1~n
    temp=scan()
    index[temp]=i

for i := 1~n
    temp=scan()
    ans += query(1,1,n,index[temp],treeSize)
    update(1,1,n,1,index[temp])
```

## 에러

없음

# 메모

풀수있는 모든 범위들을 생각했다면, 예를 들어 트리를 만들수 있다고 하면 3142...를 그대로 리프노드에 옮겨놓는 식인지, 아니면 위처럼 3번째 리프 체크, 1번째 리프 체크... 처럼 하는 식인지... 이런 방식들을 차분히 고려했다면 실마리를 잡았을 수도 있다. 앞으로는 할 수 있는 방법들을 다 생각해 본 후에야 해답을 봐야겠다.