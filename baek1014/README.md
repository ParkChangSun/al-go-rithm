# 컨닝

https://www.acmicpc.net/problem/1014

최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.

시험은 N행, M열 크기의 직사각형 교실에서 이루어진다. 교실은 1×1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.

최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.

위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.

최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.

# 내 풀이

정답. 아래에 서술함.

# 풀이

비트마스크를 활용하는 문제이기 때문에, 사용할 수 있는 변수는

1. 지금 앉혀야 하는 라인 넘버
2. 현재 라인에 앉힌 상태 비스마스크

이다. 저장해야 하는 값은 최대로 앉은 수이다.

최대 칸 수는 100개이기 때문에 함수를 실행할 때 모든 비트마스크를 줄 수는 없다. 바로 윗줄에 대한 정보만 있으면 이 칸에 앉을 수 있는지를 판별할 수 있다.

문제를 나누는 방식

- 현재 라인에 어떤 방식으로 앉혔을 때, 현재 라인보다 아래 라인에 앉힐 수 있는 최대값을 구한다.
- 현재 라인에 어떤 방식으로 앉힌 상태라면, 그 아래 라인에 앉힐 수 있는 최대값은 항상 같을 것이다. 현재 라인보다 아래 라인들은 현재 라인보다 위 라인들과는 연관성이 없으며 오직 현재 라인과만 연관되어 있기 때문이다.
- 한 자리 앉힐 때마다 그 이후의 자리 및 아래 라인의 자리를 모두 저장한다면, 현재 라인의 위 라인의 상태를 반영할 수 없다. 이 다음 자리부터 최대로 앉힐 수 있는 자리가 위 라인의 현재 상황 때문에 앉힐 수 없는 자리일 수 있다.
- 현재 라인의 상태가 확정된 이후에, 그 아래 라인부터의 최대값을 저장하거나 불러올 수 있다.

처음에는 한 자리 앉힐 때마다 값을 저장했었는데, 그러면 위 라인의 상태를 반영할 수 없다는 것을 뒤늦게 알았다. 값을 저장할 수 있는 조건 같은 것도 잘 살펴봐야 한다.

## 구현
```go
func solve(uppermask int, line int, seatMask int, seatNum int) int {
	if line == k {
		return 0
	}

	if seatNum >= l {
		// 이번 줄에 이렇게 앉힌 상태는 오직 아래에만 영향을 미친다
		// 자리 하나하나마다 저장하면 윗줄의 상태를 반영할 수 없다
		if memo[line][seatMask] == -1 {
			memo[line][seatMask] = solve(seatMask, line+1, 0, 0)
		}
		return memo[line][seatMask]
	}

	unavailable := room[line][seatNum] == X
	leftCheat := seatNum > 0 && ((uppermask>>(seatNum-1))&1) == 1
	rightCheat := seatNum < l-1 && ((uppermask>>(seatNum+1))&1) == 1
	if unavailable || leftCheat || rightCheat {
		return solve(uppermask, line, seatMask, seatNum+1)
	}

	noCase := solve(uppermask, line, seatMask, seatNum+1)
	sitCase := solve(uppermask, line, seatMask|(1<<seatNum), seatNum+2) + 1
	return max(noCase, sitCase)
}
```
이 문제는 bottom-up으로 바꾸려면 꽤나 까다로울 것 같다. 다른 사람들의 bottom-up 풀이를 봐도 꽤나 많은 반복문으로 구성되어 있었다.

## 에러

없음

# 메모

값을 저장할 수 있는 조건을 뒤늦게 알게 되었다. 다음부터는 언제 값을 저장할 수 있는지도 생각하면 좋을 것 같다.

인풋이 더 큰 문제도 있다. DP로는 풀 수 없고, 트리를 사용하는 것 같다.